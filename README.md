# TIL(2021/08/19)
## HTTP API 를 만들어 보자
## HTTP 메서드 종류 - GET, POST, PUT, PATCH, DELETE
## HTTP 메서드의 속성 (안전, 멱등, 캐싱가능)
## 클라이언트에서 서버로 데이터 전송
### 1. 데이터 전송 방식에는 2가지가 있다
#### 쿼리 파라미터를 통한 데이터 전송 (GET)
#### 메시지 바디를 통한 데이터 전송 (POST, PUT, PATCH)
### 2. 클라이언트에서 서버로 데이터 전송
#### 정적 데이터 조회 - 이미지, 정적 텍스트 문서 ( 일반적으로 쿼리 파라미터 없이 URI 주소 만으로 조회 가능)
#### 동적 데이터 조회 - 쿼리 파라미터 사용 (쿼리 파라미터를 기바능로 정렬 필터 해서 결과를 동적으로 생성)
##### - 주로 검색, 게시판 목록에서 정렬 필터(검색어)
##### - 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용
##### - 조회는 GET 사용
##### - GET은 쿼리 파라미터 사용해서 데이터를 전달
### 3. HTML FORM 데이터 전송
#### POST 전송 - 저장
#### GET 전송 - 저장 (GET 메서드는 조회에만 사용!!! 저장에 사용하면 안됨)
## HTTP API 설계 예시


TIL(2021/08/20 ~ 2021/08/23)
엘리스 코딩 3기 AI트랙 레이서 합격!!!
가족 휴가 20 ~ 21


TIL (2021/08/24)

HTTP API 설계 예시

    HTTP API - 컬렉션
        POST 기반 등록
        서버가 리소스 URI 결정
    
    HTTP API - 스토어
        PUT 기반 등록
        클라이언트가 리소스 URI 결정
    
    HTML FORM 사용
        순수 HTML + HTML form 사용
        GET, POST 지원
        컨트롤 URI 사용 (GET, POST로만 하기 제약이 있을 경우 / 예시 -> 삭제, 수정(폼사용x) 등등)

    참고하면 좋은 URI 설계 개념
        
        문서(document)
            단일 개념 (파일하나, 객체 인스턴스, 데이터베이서 row)
            예시 -> /members/100, /files/star.jpg

        컬렉션(collection)
            서버가 관리하는 리소스 디렉터리
            서버가 리소스의 URI 를 생성하고 관리
            예시 -> /members

        스토어(store)
            클라이언트가 관리하는 자원 저장소
            클라이언트가 리소스의 URI 를 알고 관리
            예시 -> /files

        컨트롤러(controller), 컨트롤 URI
            문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
            동사를 직접 사용
            예시 -> /members/{id}/delete

HTTP 상태 코드

    1xx (Informational) : 요청이 수신되어 처리중
    2xx (Successful) : 요청 정상 처리
    3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요
    4xx (Client Error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
    5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함

리다이렉션 이해
    
    영구 리다이렉션 - 특정 리소스의 URI 가 영구적으로 이동
        301 - Moved Permanently
            리다이렉트 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 (MAY)
        308 - Permanent Redirect
            리다이렉트시 요청 메서드와 본문을 유지 한체로 리다이렉트 (처음 POST를 보내면 리다이렉트도 POST)

    일시 리다이렉션 - 일시적인 변경
        주문 완료후 주문 내역 화면으로 이동
        PRG - Post / Redirect / Get
            POST 로 주문후에 웹 브라우저를 새로고침 하면? -> 새로고침은 다시 요청 -> 중복 주문이 될 수 있다.
            POST 로 주문후에 주문 결과 화면을(302) GET 메서드로 리다이렉트 -> 새로고침해도 결과 화면을 GET으로 조회

        302 - Found
            리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 (MAY)

        307 - Temporary Redirect
            리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT)

        303 - See Other
            리다이렉트시 요청 메서드가 GET으로 변경

    특수 리다이렉션 - 결과 대신 캐시를 사용
        300 - 거의 사용하지 않음

        304 - Not Modified
            캐시를 목적으로 사용
            클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
            304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬캐시를 사용해야 하므로)
            조건부 GET, HEAD요청시 사용

클라이언트 오류 (4xx)
    클라이언트의 요청에 잘못된 문법드응로 서버가 요청을 수행할 수 없음
    오류의 원인이 클라이언트에 있음
    중요! 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함

    400 - Bad Request
        클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
        요청 구문, 메시지 등등 오류
        클라이언트는 요청 내용을 다시 검토하고, 보내야함
        예시) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때

    401 - Unauthorized
        인증 되지 않음
        오류 발생시 응답에 WWW-Authenticate 헤더와 함꼐 인증 방법을 설명
        
        참고
            인증 (Authentication) : 본인이 누구인지 확인, (로그인)
            인가 (Authorization) : 권한부여
            오류 메시지가 Unauthorized 이지만 인증되지 않음

    403 - Forbidden
        서버가 요청을 이해했지만 승인을 거부함
        주로 인증 자격 증명은 있지만, 접근 구너한이 불충분한 경우
    
    404 - Not Found
        요청 리소스를 찾을수 없음
        또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때

서버 오류 (5xx)
    서버 문제로 오류 발생
    서버에 문제가 있기 떄문에 재시도 하면 성공할 수도 있음 (복구가 되거나 등등)

    500 - Internal Server Error
        서버 문제로 오류 발생, 매매하면 500 오류
    
    503 - Service Unavailable
        서비스 이용 불가
        서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
        Retry-After 헤더 필드로 얼마뒤에 복귀되는지 보낼수도 있음

HTTP 헤더

    HTTP 전송에 필요한 모든 부가정보
        예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증 등등
    
    헤더 분류 (과거!!!)
        - General 헤더 : 메시지 전체에 적용되는 정보
        - Request 헤더 : 요청 정보
        - Response 헤더 : 응답 정보
        - Entity 헤더 : 엔티티 바디 정보 / 엔티티 본문의 데이터를 해석할 수 있는 정보 제공 (데이터 유형, 데이터 길이, 압축 정보 등등)
    
    RFC723X 변화
        엔티티 -> 표현 (Representation)
        표현 = 표현 메타데이터 + 표현 데이터
        메시지 본문 = 페이로드
        표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
        Content-Type -> 표현 데이터의 형식
        Content-Encoding -> 표현 데이터의 압축 방식
        Content-Language -> 표현 데이터의 자연 언어
        Content-Length -> 표현 데이터의 길이


표현(Representation)

    Content-Type ->표현 데이터의 형식
        미디어 타입, 문자 인코딩

    Content-Encoding -> 표현 데이터의 압축 방식
        표현 데이터를 압축하기 위해 사용
        데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
        데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제

    Content-Language -> 표현 데이터의 자연 언어
        영어, 한국어, 등등

    Content-Length -> 표현 데이터의 길이
        바이트 단위
        Transfer-Encoding(전송코딩)을 사용하면 Content-Length를 사용하면 안됨

협상(콘텐츠 네고시에이션)

    Accept -> 클라이언트가 선호하는 미디어 타입 전달

    Accept-Charset -> 클라이언트가 선호하는 문자 인코딩

    Accept-Encoding -> 클라이언트가 선호하는 압축 인코딩

    Accept-Language -> 클라이언트가 선호하는 자연 언어

    협상 헤더는 요청시에만 사용

협상과 우선순위 1

    Quality Values(q) 값 사용
    0 ~ 1 , 클수록 높은 우선순위 (생략하면 1)
    Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
                       1        2         3        4

협상과 우선순위 2

    구체적인 것이 우선한다.
    Accept: text/*, text/plain, text/plain:format=flowed, */*
               3          2               1                4

협상과 우선순위 3

    구체적인 것을 기준으로 미디어 타입을 맞춘다
    Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5

전송방식

    단순전송 -> 컨텐츠 길이를 알 수 있을때 사용(Content-Length)

    압축전송 -> 컨텐츠 인코딩(Content-Encoding)을 알고 있을때 압축하여 전송
    
    분할전송 -> 컨텐츠를 분할하여 전송할때 (Tranfer-Encoding: chunked), 용량이 큰 컨텐츠를 분할하여 전송할때 사용
            *** 컨텐츠 길이를 사용하면 안됨

    범위전송 -> 범위를 지정하여 전송할때 사용 (Content-Range)
              (클라이언트가 서버에 컨텐츠를 요구할때, 자신이 이미 받은 컨텐츠가 있고 그 외 더 추가적인 컨텐츠를 요청할때 사용)

일반정보

    From -> 유저 에이전트의 이메일 정보
    Referer -> 이전 웹 페이지 주소 (요청에서 사용)
    User-Agent -> 클라이언트 에플리케이션 정보
    Server -> 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보 (응답에서 사용)
    Date -> 메시지가 발생한 날짜와 시간 (응답에서 사용)

특별한 정보

    Host -> 요청한 호스트 정보(도메인), 요청에서 사용, **필수**, 하나의 서버가 여러 도메인을 처리할때 사용됨
    
    Location -> 페이지 리다이렉션, 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)

    Allow -> 허용 가능한 HTTP 메서드

    Retry-After -> 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

인증

    Authorization -> 클라이언트 인증 정보를 서버에 전달

    WWW-Authenticate -> 리소스 접근시 필요한 인증 방법 정의 (401 Unauthorized 응답과 함께 사용)

쿠키

    Set-Cookie -> 서버에서 클라이언트로 쿠키 전달(응답)

    Cookie -> 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
    
    사용처
        사용자 로그인 세션 관리
        광고 정보 트래킹

    쿠키 정보는 항상 서버에 전송됨
        네트워크 트래픽 추가 유발
        최소한의 정보만 사용(세션 id, 인증 토큰)
        서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage) 참고
    
    • 주의!
        보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)

쿠키 - 생명주기
    Expires -> 만료일이 되면 쿠키 삭제
    Max-age -> 초단위로 쿠케 생명주기 설정 (0 이나 음수를 지정하면 쿠키 삭제)

    세션 쿠키 -> 만료날짜를 생략하면 브라우저 종료시 까지만 유지
    영속 쿠키 -> 만료날짜를 입력하면 해당 날짜까지 유지

쿠키 - 도메인
    명시 -> 명시한 문서 기준 도메인 + 서브 도메인 포함
    생략 -> 현재 문서 기준 도메인만 적용

쿠키 - 경로
    이 경로를 포함한 하위경로 페이지만 쿠키 접근
    일반적으로 path=/ 루트로 지정

쿠키 - 보안
    Secure -> 쿠키는 http, https를 구분하지 않고 전송하게 되어있으나, Secure 인 경우에는 https인 경우에만 전송
    
    HttpOnly -> XSS 공격 방지, 자바스크립트에서 접근 불가(document.cookie), HTTP 전송에만 사용

    SameSite -> XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송

모든 요청에 정보를 넘기는 문제
    
    모든 요청에 사용자 정보가 포함되도록 개발 해야함
    브라우저를 완전히 종료하고 다시 열면?
    
    -> 쿠키를 저장하고 다음 요청을 보낼떄, 쿠키 저장소를 검색하여 무조건 포함하도록 설계


Stateless

    HTTP는 무상태 프로토콜이다.
    클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
    클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
    클라이언트와 서버는 서로 상태를 유지 하지 않는다.
    

캐시 기본 동작

    캐시가 없을 때
        데이터가 변경되지 않아도 계쏙 네트워크를 통해서 데이터를 다운로드 받아야 한다.
        인터넷 네트워크는 느리고 매우 느리고 비싸다.
        브라우저 로딩 속도가 느리다.
        느린 사용자 경험

    캐시가 있을 때
        캐시 덕분에 캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다.
        비싼 네트워크 사용량을 줄일 수 있다.
        브라우저 로딩 속도가 매우 빠르다.
        빠른 사용자 경험

    캐시 시간 초과
        캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다.
        이때 다시 네트워크 다운로드가 발생한다.
        
     